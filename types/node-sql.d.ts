// Type definitions for node-sql v0.74.0
// Project: https://github.com/node-sql
// Definitions by: me <https://github.com/InDIOS>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped

declare namespace nodesql {
	interface SQLConfigOptions {
		table?: string;
		[key: string]: any;
	}

	interface TableDefinition extends NodeDefinition {
		name: string;
		columns: ObjectColumnDefinition | (string | ColumnDefinition)[];
		columnWhiteList?: any;
		isTemporary?: boolean;
		snakeToCamel?: boolean;
	}

	interface ObjectColumnDefinition {
		[key: string]: { dataType: string };
	}

	interface ColumnDefinition {
		name: string;
		dataType: string;
		primaryKey?: boolean;
		property?: string;
		alias?: string;
		star?: string;
		isConstant?: boolean;
		constantValue?: string | number;
		asArray?: any[];
		aggregator?: any;
		table?: Table;
		getValue?: () => string | number;
		distinct?: boolean;
		notNull?: boolean;
		defaultValue?: string | number;
		references?: any;
		subfieldContainer?: any;
		subfields?: any;
		autoGenerated?: boolean;
		unique?: boolean;
	}

	interface NodeDefinition {
		[key: string]: any;
	}

	class Expressions {
		isNull(): PostfixUnaryNode;
		isNotNull(): PostfixUnaryNode;
		equals(value: string | number | Node | Column | (string | number | Node | Column)[]): BinaryNode;
		equal(value: string | number | Node | Column | (string | number | Node | Column)[]): BinaryNode;
		notEquals(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		notEqual(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		gt(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		gte(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		lt(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		lte(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		plus(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		minus(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		multiply(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		divide(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		modulo(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		leftShift(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		rightShift(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		bitwiseAnd(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		bitwiseNot(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		bitwiseOr(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		bitwiseXor(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		regex(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		iregex(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		regexp(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		notRegex(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		notIregex(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		concat(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		key(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		keyText(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		path(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		pathText(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		like(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		rlike(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		notLike(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		ilike(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		notIlike(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		match(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		in(value: string | number | Node | (string | number | Node)[]): InNode;
		notIn(value: string | number | Node | (string | number | Node)[]): NotInNode;
		between(middle: string | number | Node | (string | number | Node)[], right: string | number | Node | (string | number | Node)[]): TernaryNode;
		notBetween(middle: string | number | Node | (string | number | Node)[], right: string | number | Node | (string | number | Node)[]): TernaryNode;
		at(index: number): AtNode;
		contains(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		containedBy(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		containsKey(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		overlap(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		slice(start: number): SliceNode;
		cast(dataType: string): CastNode;
		descending(): OrderByValueNode;
		case(whenList: (string | number | Node)[], thenList: (string | number | Node)[], elseBranch?: string | number | Node | (string | number | Node)[]): CaseNode;
	}

	class ExpressionsNode extends AliasMixin {
		isNull(): PostfixUnaryNode;
		isNotNull(): PostfixUnaryNode;
		equals(value: string | number | Node | Column | (string | number | Node | Column)[]): BinaryNode;
		equal(value: string | number | Node | Column | (string | number | Node | Column)[]): BinaryNode;
		notEquals(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		notEqual(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		gt(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		gte(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		lt(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		lte(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		plus(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		minus(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		multiply(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		divide(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		modulo(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		leftShift(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		rightShift(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		bitwiseAnd(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		bitwiseNot(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		bitwiseOr(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		bitwiseXor(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		regex(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		iregex(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		regexp(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		notRegex(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		notIregex(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		concat(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		key(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		keyText(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		path(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		pathText(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		like(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		rlike(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		notLike(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		ilike(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		notIlike(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		match(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		in(value: string | number | Node | (string | number | Node)[]): InNode;
		notIn(value: string | number | Node | (string | number | Node)[]): NotInNode;
		between(middle: string | number | Node | (string | number | Node)[], right: string | number | Node | (string | number | Node)[]): TernaryNode;
		notBetween(middle: string | number | Node | (string | number | Node)[], right: string | number | Node | (string | number | Node)[]): TernaryNode;
		at(index: number): AtNode;
		contains(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		containedBy(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		containsKey(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		overlap(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		slice(start: number): SliceNode;
		cast(dataType: string): CastNode;
		descending(): OrderByValueNode;
		case(whenList: (string | number | Node)[], thenList: (string | number | Node)[], elseBranch?: string | number | Node | (string | number | Node)[]): CaseNode;
	}

	class ExpressionsMixin extends Expressions {
		or(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		and(value: string | number | Node | (string | number | Node)[]): BinaryNode;
	}

	class ExpressionsMixinNode extends ExpressionsNode {
		or(value: string | number | Node | (string | number | Node)[]): BinaryNode;
		and(value: string | number | Node | (string | number | Node)[]): BinaryNode;
	}

	class Table extends TableNode {
		define(definition: TableDefinition): Table;
		clone(definition: TableDefinition): Table;
		createColumn(column: string | Column): Column;
		addColumn(columnName: string, definition: ColumnDefinition): Table;
		hasColumn(column: string | Column): boolean;
		get(columnName: string): Column;
		getColumn(columnName: string): Column;
		getSchema(): any;
		setSchema(schema: string): void;
		getName(): string;
		star(options?: any): Column;
		literal(literal: any): LiteralNode;
		count(alias?: string): Column;
		toNode(): TableNode;
		join(other: Table): JoinNode;
		leftJoin(other: Table): JoinNode;
		joinTo(other: Table): JoinNode;
		as(alias: string): Table;
		indexes(): Query;
		subQuery(alias: string): Query;
		insert(value: Node | { [key: string]: any } | (Node | { [key: string]: any })[]): Query;
		select(...args: (string | Column | string[])[]): Query;
		and(): Query;
		alter(): Query;
		create(): Query;
		delete(): Query;
		drop(): Query;
		from(): Query;
		limit(limit: number): Query;
		offset(offset: number): Query;
		or(): Query;
		order(): Query;
		truncate(): Query;
		update(value: { [key: string]: any }): Query;
		where(): Query;
	}

	class Column extends ExpressionsMixin {
		table: Table;
		asc: Column
		desc: OrderByValueNode
		ascending: Column
		dataType: string;
		defaultValue: string | number;
		constructor(config: ColumnDefinition);
		value(value: string | number): Object;
		getValue(): string | number;
		toNode(): ColumnNode;
		as(alias: string): ColumnNode;
		arrayAgg(alias: string): ColumnNode;
		aggregate(alias: string, aggregator: string): ColumnNode;
		count(alias: string): ColumnNode;
		max(alias: string): ColumnNode;
		min(alias: string): ColumnNode;
		sum(alias: string): ColumnNode;
		avg(alias: string): ColumnNode;
		distinct(): ColumnNode;
		toQuery(): Query
	}

	class Node {
		type: string;
		define(definition: NodeDefinition): Node;
		add(node: string | Node): Node;
		addAll(nodes: (string | Node)[]): Node;
		unshift(node: string | Node): Node;
		toQuery(dialect?: string): Query;
		toNamedQuery(name: string, dialect: string): Query;
		toString(dialect: string): string;
	}

	class Query extends ExpressionsNode {
		sql: string;
		name: string;
		type: string;
		text: string;
		table: Table;
		values: (string | number | boolean)[]
		constructor(table: Table);
		define(definition: NodeDefinition): Node;
		add(node: string | Node): Node;
		addAll(nodes: (string | Node)[]): Node;
		unshift(node: string | Node): Node;
		toQuery(dialect?: string): Query;
		toNamedQuery(name: string, dialect?: string): Query;
		toString(dialect: string): string;
		select(...args: (string | string[])[]): Query;
		from(tableNodes: Table | Node | Table[], ...args: Table[]): Query;
		star(): Column;
		leftJoin(other: Node): JoinNode;
		where(...nodes: Node[]): Query;
		order(...nodes: (Column | Node)[]): Query;
		group(...nodes: Node[]): Query;
		having(...nodes: Node[]): Query;
		create(): Query;
		create(indexName: string): CreateIndexNode;
		drop(...columns: ColumnNode[]): Query;
		insert(value: { [key: string]: any } | { [key: string]: any }[] | Node, ...nodes: Node[]): Query;
		update(value: { [key: string]: any }): Query;
		onDuplicate(value: { [key: string]: any }): Query;
		onConflict(value: { [key: string]: any }): Query;
		parameter(value: string | number | Node): Query;
		delete(tableNodes?: Table | Table[]): Query;
		returning(...values: string[]): Query;
		or(node: Node): Query;
		and(node: Node): Query;
		forUpdate(): Query;
		forShare(): Query;
		truncate(): Query;
		distinct(): Query;
		alter(): Query;
		ifExists(): Query;
		ifNotExists(): Query;
		orIgnore(): Query;
		cascade(): Query;
		restrict(): Query;
		indexes(): Query;
		exists(): PrefixUnaryNode;
		notExists(): PrefixUnaryNode;
		limit(count: number): Query;
		offset(count: number): Query;
		as(alias: string): AliasNode;
		createView(viewName: string): Query;
		distinctOn(...args: (string | string[])[]): Query;
		rename(newName: string | Column): Query;
		addColumn(column: Column): Query;
		addColumn(column: string, dataType: string): Query;
		dropColumn(column: string | Column): Query;
		renameColumn(oldColumn: string | Column, newColumn: string | Column): Query;
	}

	class AliasNode extends Node {
		value: string;
		alias: string;
		constructor(value: string, alias: string);
	}

	class AliasMixin extends Node {
		as(alias: string): AliasNode;
	}

	class AtNode extends AliasMixin {
		value: string;
		index: number;
		constructor(value: string, index: number);
	}

	class BinaryNode extends ExpressionsMixinNode {
		operator: string;
		left: string | number;
		right: string | number;
		constructor(config: { operator: string, left: string | number, right: string | number });
	}

	class CaseNode extends AliasMixin {
		else: string;
		whenList: string;
		thenList: string;
		constructor(config: { else: string, whenList: string, thenList: string });
	}

	class CastNode extends AliasMixin {
		value: string;
		dataType: string;
		constructor(value: string, dataType: string);
	}

	class CreateNode extends Node {
		isTemporary: boolean;
		constructor(isTemporary: boolean);
	}

	class CreateIndexNode extends Node {
		isTemporary: boolean;
		options: {
			indexName: string;
			columns: Column[];
			algorithm: string;
			parser: any;
		}
		constructor(table: Table, indexName: string);
		indexName(): string;
		unique(): CreateIndexNode;
		spatial(): CreateIndexNode;
		fulltext(): CreateIndexNode;
		on(...args: Column[]): CreateIndexNode;
		withParser(parser: any): CreateIndexNode;
		using(algorithm: string): CreateIndexNode;
	}

	class CreateViewNode extends Node {
		options: { viewName: string };
		constructor(viewName: string);
	}

	class DeafultNode extends Node {
		value(): void;
	}

	class DropNode extends Node {
		constructor(table: Table);
	}

	class DropIndexNode extends Node {
		table: Table;
		options: { indexName: string, columns: ColumnNode[] };
		constructor(table: Table, indexName: ColumnNode[]);
	}

	class ForeingKeyNode extends Node {
		name: string;
		columns: ColumnNode[];
		schema: any;
		table: Table;
		refColumns: ColumnNode[];
		onUpdate: Function;
		onDelete: Function;
		constraint: any;
		constructor(config: {
			name?: string;
			columns?: ColumnNode[];
			schema?: any;
			table?: Table;
			refColumns?: ColumnNode[];
			onUpdate?: Function;
			onDelete?: Function;
			constraint?: any;
		});
	}

	class FunctionCallNode extends AliasMixin {
		name: string;
		constructor(name: string, ...args: any[]);
	}

	class SelectNode extends Node {
		sql: string;
		isDistinct: boolean;
		msSQLLimitNode: Node;
		constructor(table: Table);
	}

	class SliceNode extends AliasMixin {
		value: string;
		start: number;
		end: number;
		constructor(value: string, start: number, end: number);
	}

	class TernaryNode extends AliasMixin {
		middle: any;
		operator: string
		left: Node;
		right: Node;
		separator: string;
		constructor(config: {
			middle: any;
			operator: string
			left: Node;
			right: Node;
			separator: string;
		});
	}

	class TextNode extends Node {
		text: string;
		constructor(text: string);
	}

	class TableNode extends Node {
		table: Table;
		constructor(table: Table);
	}

	class TruncateNode extends Node {
		constructor(table: Table);
	}

	class ColumnNode extends Node {
		name: string;
		property: string;
		alias: string;
		star: string;
		isConstant: boolean;
		constantValue: string | number;
		asArray: any[];
		aggregator: any;
		table: Table;
		getValue: string | number;
		dataType: string;
		distinct: boolean;
		primaryKey: boolean;
		notNull: boolean;
		defaultValue: string | number;
		references: any;
		subfieldContainer: any;
		subfields: any;
		autoGenerated: boolean;
		unique: boolean;
		constructor(config: ColumnDefinition);
	}

	class IndexesNode extends Node {
		table: Table;
		constructor(table: Table);
	}

	class InsertNode extends Node {
		names: string[];
		columns: ColumnNode[];
		valueSets: any[];
		getParameters(): any[];
	}

	class IntervalNode extends Node {
		years: string;
		months: string;
		days: string;
		hours: string;
		minutes: string;
		seconds: string;
		constructor(config: {
			years?: string;
			months?: string;
			days?: string;
			hours?: string;
			minutes?: string;
			seconds?: string;
		});
	}

	class JoinNode extends Node {
		sql: string;
		subType: string;
		from: Node;
		to: Node;
		constructor(subType: string, from: Node, to: Node);
		on(node: Node): JoinNode;
		join(other: Node): JoinNode;
		leftJoin(other: Node): JoinNode;
	}

	class InNode extends AliasMixin {
		left: Node;
		right: Node;
		constructor(config: { left: Node, right: Node });
	}

	class NotInNode extends AliasMixin {
		left: Node;
		right: Node;
		constructor(config: { left: Node, right: Node });
	}

	class LiteralNode extends Node {
		alias: string;
		literal: string;
		constructor(literal: string);
		as(alias: string): LiteralNode;
	}

	class OrderByValueNode extends Node {
		direction: string;
		msSQLLimitNode: Node;
		msSQLOffsetNode: Node;
		value: string | number;
		constructor(config: { value: string | number, direction: string });
	}

	class ParameterNode extends Node {
		private _val: string;
		isExplicit: boolean;
		constructor(val: string);
		static getNodeOrParameterNode(value: string | number | Node): ParameterNode;
	}

	class PostfixUnaryNode extends AliasMixin {
		operator: string;
		left: Node;
		constructor(config: { operator: string, left: Node });
	}

	class PrefixUnaryNode extends AliasMixin {
		operator: string;
		left: Node;
		constructor(config: { operator: string, left: Node });
	}

	class WhereNode extends Node {
		table: Table;
		constructor(table: Table);
		add(other: Node): Node;
		and(other: Node): Node;
		or(other: Node): Node;
	}

	class AddColumnNode extends Node { }
	class AlterNode extends Node { }
	class ArrayCallNode extends AliasMixin { }
	class CascadeNode extends Node { }
	class DeleteNode extends Node { }
	class DistinctNode extends Node { }
	class DistinctOnNode extends Node { }
	class DropColumnNode extends Node { }
	class ForShareNode extends Node { }
	class ForUpdateNode extends Node { }
	class FromNode extends Node { }
	class GroupByNode extends Node { }
	class HavingNode extends Node { }
	class IfExistsgNode extends Node { }
	class IfNotExistsgNode extends Node { }
	class OnConflictNode extends Node { }
	class OnDuplicateNode extends Node { }
	class OrderByNode extends Node { }
	class OrIgnoreNode extends Node { }
	class RenameNode extends Node { }
	class RenameColumnNode extends Node { }
	class RestrictNode extends Node { }
	class ReturningNode extends Node { }
	class UpdateNode extends Node { }

	class SQL {
		SQL: typeof SQL;
		Table: typeof Table;
		dialectName: string;
		constructor(dialect: string, config: SQLConfigOptions);
		define(definition: TableDefinition): Table;
		create(dialect: string, config: SQLConfigOptions): SQL;
		select(table: string | Table): Query;
		constant(value: string | number | boolean): Column;
		setDialect(dialect: string, config?: SQLConfigOptions): SQL;
		interval(): IntervalNode;
		functionCallCreater(name: string): Function;
		array(...args: any[]): any;
	}
}

declare module 'sql' {
	let sql: nodesql.SQL;
	export = sql;
}
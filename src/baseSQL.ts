import * as sql from 'sql';
import { eachKey, keys, selectFields, getIdType } from './utils';
import {
	Adapter, AdapterDefinition, IndexOption,
	FieldOptions, ConditionOptions
} from './types';

abstract class BaseSQL extends Adapter {

	private sql: nodesql.SQL;
	readonly name: string;
	protected _models: { [key: string]: AdapterDefinition };

	constructor(dialect: string) {
		super();
		this._models = {};
		this.sql = sql.setDialect(dialect);
	}

	protected abstract toDatabaseDate(date: Date);
	protected abstract query<T>(sql: string, values?: (string | number | boolean)[]): Promise<T[]>;

	private getPKeyName(modelName: string) {
		return this._models[modelName].pKeys[0];
	}

	private getColumns(modelName: string) {
		return keys(this._models[modelName].properties);
	}

	private getTable(modelName: string) {
		let props = this.getColumns(modelName);
		let { properties, pKeys } = this._models[modelName];
		let columns: nodesql.ColumnDefinition[] = [];
		props.forEach(prop => {
			let property = properties[prop];
			let column: nodesql.ColumnDefinition = {
				name: prop,
				dataType: this.dataTypes(property.type, property.precision, property.decimals),
				notNull: !!property.nullable
			};
			let pkey = pKeys.find(key => key.pKey === prop);
			if (pkey) {
				column.dataType = this.dataTypes(getIdType(this.name));
				column.primaryKey = true;
				if (pkey.generated) {
					column.autoGenerated = true;
				}
			} else {
				column.unique = !!property.unique;
				column.defaultValue = property.default;
			}
			columns.push(column);
		});
		return this.sql.define({ name: modelName, columns });
	}

	define(definition: AdapterDefinition) {
		let { model: { modelName } } = definition;
		this._models[modelName] = definition;
		let table = this.getTable(modelName);
		let createSql = table.create().ifNotExists().toQuery().text;
		this.query<void>(createSql).then(() => {
			let indexes: { keys: Array<nodesql.Column>, name: string, unique: boolean }[] = [];
			eachKey(definition.properties, prop => {
				let property = definition.properties[prop];
				if (property.index || property.unique) {
					let index = indexes.findIndex(i => i.name === property.index);
					if (~index) {
						indexes[index].keys.push(table.get(prop));
					} else {
						let newIndex = {
							keys: [table.get(prop)],
							unique: !!property.unique,
							name: typeof property.index === 'string' ? property.index : `index_${prop}_field`
						};
						indexes.push(newIndex);
					}
				}
			});
			let promises = indexes.map(({ name, unique, keys }) => {
				let index = table.indexes().create(name);
				if (unique) {
					index.unique();
				}
				let stm = index.on(...keys).toQuery().text;
				let pos = stm.indexOf('INDEX') + 5;
				stm = `${stm.substring(0, pos)} IF NOT EXISTS${stm.substring(pos, stm.length)}`;
				return this.query<void>(stm);
			});
			return Promise.all(promises);
		}).catch(err => console.log(err));
	}

	defineProperty(modelName: string, field: string, params: FieldOptions) {
		this._models[modelName].properties[field] = params;
		let table = this.getTable(modelName);
		let query = table.alter().addColumn(field, this.dataTypes(params.type)).toQuery().text;
		if (this.name === 'sqlite') {
			this.query<{ name: string }>(`PRAGMA table_info(${modelName})`)
				.then(cols => {
					if (cols.every(col => col.name !== field)) {
						return this.query(query);
					}
				}).catch(err => console.log(err));
		} else {
			this.query(query).catch(err => console.log(err));
		}
	}

	ensureIndex(modelName: string, fields: string | string[], params?: IndexOption): Promise<void> {
		let table = this.getTable(modelName);
		let name = '', isUnique = false;
		let voidThen = () => { };
		if (typeof fields === 'string') {
			setValues(fields);
			let index = table.indexes().create(name);
			if (isUnique) {
				index.unique();
			}
			return this.query<void>(index.on(table.get(fields)).toQuery().text).then(voidThen);
		} else {
			setValues(fields.join('_'));
			let index = table.indexes().create(name);
			if (isUnique) {
				index.unique();
			}
			let columns = fields.map(field => table.get(field));
			return this.query<void>(index.on(...columns).toQuery().text).then(voidThen);
		}

		function setValues(prop: string) {
			if (typeof params === 'string') {
				name = params;
			} else if (typeof params === 'boolean') {
				isUnique = params;
			} else if (typeof params === 'object') {
				name = params.name || `index_${prop}_field`;
				isUnique = !!params.unique;
			} else {
				name = `index_${prop}_field`;
			}
		}
	}

	exists(modelName: string, id: number | string): Promise<boolean> {
		let table = this.getTable(modelName);
		let { text, values } = table.select('1')
			.where(table.get(this.getPKeyName(modelName).pKey).equals(id)).limit(1).toQuery();
		return this.query<number>(text, values).then(rows => !!rows[0]);
	}

	count(modelName: string, query: ConditionOptions): Promise<number> {
		let table = this.getTable(modelName);
		let where = buildWhere(table, query.where);
		let { text, values } = table.select(table.count()).where(...where).toQuery();
		return this.query<number>(text, values).then(rows => rows[0]);
	}

	create<M, N>(modelName: string, data: M): Promise<N> {
		let { pKey } = this.getPKeyName(modelName);
		let { text, values } = this.getTable(modelName).insert(this.toDatabase(data, pKey)).toQuery();
		return this.query<N>(text, values)
			.then(rows => {
				let row = typeof rows[0] === 'object' ? rows[0][pKey] : rows[0];
				return this.find<N>(modelName, { where: { [pKey]: row } });
			}).then(rows => rows[0]);
	}

	save<M, N>(modelName: string, data: M): Promise<N> {
		let { pKey } = this.getPKeyName(modelName);
		return this
			.update<M, N>(modelName, { where: { [pKey]: data[pKey] } }, this.toDatabase(data, pKey))
			.then(rows => rows[0]);
	}

	find<M>(modelName: string, query: ConditionOptions): Promise<M[]> {
		let table = this.getTable(modelName);
		let cols = this.getColumns(modelName);
		let { pKey } = this.getPKeyName(modelName);
		let { text, values } = parseConditions(table, cols, pKey, query, table.select()).toQuery();
		return this.query<M>(text, values)
			.then(rows => rows.map(row => this.fromDatabase(modelName, row)));
	}

	update<M, N>(modelName: string, query: ConditionOptions, data: M): Promise<N[]> {
		let table = this.getTable(modelName);
		let { pKey } = this.getPKeyName(modelName);
		return this.find<M>(modelName, query).then(frows => {
			let where = buildWhere(table, query.where);
			let { text, values } = table.update(this.toDatabase(data, pKey)).where(...where).toQuery();
			return this.query<N>(text, values)
				.then(({ length }) => length ? frows.map(row => row[pKey]) : []);
		}).then(rows => {
			return !!rows.length ? this.find<N>(modelName, { where: { [pKey]: { in: rows } } }) : [];
		});
	}

	updateOrCreate<M, N>(modelName: string, query: ConditionOptions, data: M): Promise<N[]> {
		return this.find(modelName, query)
			.then(({ length }) => !length ? this.create<M, N>(modelName, data)
				.then(record => [record]) : this.update<M, N>(modelName, query, data));
	}

	remove(modelName: string, query: ConditionOptions): Promise<boolean> {
		let table = this.getTable(modelName);
		let where = buildWhere(table, query.where);
		let { text, values } = table.delete().where(...where).toQuery();
		return this.query<number>(text, values).then(rows => !!rows[0]);
	}

	removeById(modelName: string, id: number | string | Object): Promise<boolean> {
		return this.remove(modelName, { where: { [this.getPKeyName(modelName).pKey]: id } });
	}

	removeAll(modelName: string): Promise<void> {
		let table = this.getTable(modelName);
		let { text, values } = table.delete().toQuery();
		return this.query<void>(text, values).then(rows => { });
	}

	protected toDatabase<M>(data: M, pKey: string) {
		if (data[pKey] === null || data[pKey] === void 0) {
			delete data[pKey];
		}
		eachKey(data, field => {
			if (data[field] instanceof Date) {
				data[field] = this.toDatabaseDate(data[field]);
			} else if (typeof data[field] === 'object') {
				try {
					data[field] = JSON.stringify(data[field]);
				} catch (error) {
					console.log(error);
				}
			}
			if (data[field] === void 0) {
				data[field] = null;
			}
		});
		return data;
	}

	protected fromDatabase<M, N>(modelName: string, data: M): N {
		let clean = {};
		let [pKey] = this._models[modelName].pKeys;
		let { properties } = this._models[modelName];
		eachKey(data, key => {
			if (properties[key]) {
				if (data[key] === 'null' || data[key] === void 0) {
					clean[key] = null;
				} else if (properties[key].type === 'date') {
					clean[key] = new Date(data[key]);
				} else if (properties[key].type === 'json' && typeof data[key] === 'string') {
					try {
						clean[key] = JSON.parse(data[key]);
					} catch (err) { }
				} else if (properties[key].type === 'boolean') {
					clean[key] = !!data[key];
				} else {
					clean[key] = data[key];
				}
			}
		});
		clean[pKey.pKey] = data[pKey.pKey] || data['id'];
		return <N>clean;
	}

	/**
	 *  SQL General Data Types: https://www.w3schools.com/sql/sql_datatypes_general.asp
	 * -------------------------------------------------------------------------------------------------
	 * | Data type 	                        |  Description
	 * -------------------------------------------------------------------------------------------------
	 * | CHARACTER(n)                       |  Character string. Fixed-length n
	 * | VARCHAR(n) or CHARACTER VARYING(n) |  Character string. Variable length. Maximum length n
	 * | BINARY(n)                          |  Binary string. Fixed-length n
	 * | BOOLEAN                            |  Stores TRUE or FALSE values
	 * | VARBINARY(n) or BINARY VARYING(n)  |  Binary string. Variable length. Maximum length n
	 * | INTEGER(p)                         |  Integer numerical (no decimal). Precision p
	 * | SMALLINT                           |  Integer numerical (no decimal). Precision 5
	 * | INTEGER                            |  Integer numerical (no decimal). Precision 10
	 * | BIGINT                             |  Integer numerical (no decimal). Precision 19
	 * | DECIMAL(p,s)                       |  Exact numerical, precision p, scale s. Example: decimal(5,2) is a number that has 3 digits before the decimal and 2 digits after the decimal
	 * | NUMERIC(p,s) 	                    |  Exact numerical, precision p, scale s. (Same as DECIMAL)
	 * | FLOAT(p) 	                        |  Approximate numerical, mantissa precision p. A floating number in base 10 exponential notation. The size argument for this type consists of a single number specifying the minimum precision
	 * | REAL 	                            |  Approximate numerical, mantissa precision 7
	 * | FLOAT 	                            |  Approximate numerical, mantissa precision 16
	 * | DOUBLE PRECISION 	                |  Approximate numerical, mantissa precision 16
	 * | DATE 	                            |  Stores year, month, and day values
	 * | TIME 	                            |  Stores hour, minute, and second values
	 * | TIMESTAMP 	                        |  Stores year, month, day, hour, minute, and second values
	 * | INTERVAL 	                        |  Composed of a number of integer fields, representing a period of time, depending on the type of interval
	 * | ARRAY 	                            |  A set-length and ordered collection of elements
	 * | MULTISET 	                        |  A variable-length and unordered collection of elements
	 * | XML 	                              |  Stores XML data
	 * -------------------------------------------------------------------------------------------------
	 */
	protected dataTypes(propType: string, precision?: number, scale?: number) {
		switch (propType) {
			case 'string':
				return `CHARACTER VARYING(${precision || 255})`;
			case 'varchar':
				return `VARCHAR(${precision || 255})`;
			case 'text':
			case 'json':
				return `CHARACTER(${precision || 255})`;
			case 'uuid':
				return `VARCHAR(36)`;
			case 'blob':
			case 'bytes':
				return `BINARY(${precision || 0})`;
			case 'boolean':
			case 'tinyint':
				return `BOOLEAN`;
			case 'number':
				return `BIGINT`;
			case 'int':
				return `INTEGER${precision ? `(${precision})` : ''}`;
			case 'double':
				return `DOUBLE PRECISION`;
			case 'real':
				return `REAL`;
			case 'date':
				return `DATE`;
			case 'timestamp':
				return 'TIMESTAMP';
			case 'timeuuid':
				return 'TIME';
			case 'array':
				return 'ARRAY';
			case 'float':
				return `${precision && scale ? `DECIMAL(${precision}, ${scale})` : `FLOAT${precision ? `(${precision})` : ''}`}`;
			default:
				return propType;
		}
	}
}

export = BaseSQL;

function buildWhere(model: nodesql.Table, where: Object) {
	let conditions: nodesql.Node[] = [];
	for (let field in where) {
		let modelField = model.get(field);
		if (where.hasOwnProperty(field)) {
			let cond = where[field];
			if (cond === null) {
				conditions.push(modelField.isNull());
			} else if (typeof cond === 'object') {
				for (let condType in cond) {
					if (cond.hasOwnProperty(condType)) {
						let value = cond[condType];
						switch (condType) {
							case 'gt':
							case 'gte':
							case 'lt':
							case 'lte':
							case 'in':
							case 'like':
							case 'regexp':
								conditions.push(modelField[condType](value));
								break;
							case 'between':
								conditions.push(modelField.between(value[0], value[1]));
								break;
							case 'inq':
								conditions.push(modelField.in(value));
								break;
							case 'nin':
								conditions.push(modelField.notIn(value));
								break;
							case 'ne':
							case 'neq ':
								conditions.push(modelField.notEqual(value));
								break;
							case 'nlike':
								conditions.push(modelField.notLike(value));
								break;
							default:
								conditions.push(modelField.equal(value));
								break;
						}
					}
				}
			} else if (/^\//gi.test(cond)) {
				let [, regexp] = cond.split('/');
				conditions.push(modelField.regexp(regexp));
			} else {
				conditions.push(modelField.equal(cond));
			}
		}
	}
	return conditions;
}

function parseConditions(model: nodesql.Table, props: string[], pKey: string, query: ConditionOptions, querySQL: nodesql.Query) {
	let { where, fields, limit, skip, order } = query;
	if (fields) {
		let select = selectFields(fields, pKey, props);
		querySQL = model.select(...select.map(key => model.get(key)));
	}

	if (where && typeof where === 'object') {
		let wheres = buildWhere(model, where);
		querySQL.where(...wheres);
	}

	if (limit) {
		querySQL.limit(limit);
	}

	if (skip) {
		let orders: (nodesql.Column | nodesql.Node)[] = [];
		if (order) {
			for (let key in order) {
				if (order.hasOwnProperty(key)) {
					let dir = order[key];
					orders.push(model.get(key)[dir === 1 ? 'asc' : 'desc']);
				}
			}
		} else {
			orders.push(model.get(pKey).asc);
		}
		querySQL.order(...orders).offset(skip);
	}

	return querySQL;
}